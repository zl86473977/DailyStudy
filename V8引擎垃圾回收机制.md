# 垃圾回收机制有两种方式：引用法 和 标记法
[原文地址](https://juejin.cn/post/6995706341041897486)
## 引用法
就是判断一个对象的引用数，引用数为0就回收，引用数大于0就不回收

    let obj1 = { name: 'jelon', age: 22 }
    let obj2 = obj1
    let obj3 = obj1
    
    obj1 = null
    obj2 = null
    obj3 = null
随着obj1,obj2,obj3依次置空，堆内存中的内存块引用数为3，2，1，0，然后被释放。
但是此种方式也是有缺点的，如果存在互相引用，各自引用数都是1，则不会被回收，从而造成内存泄漏。

## 标记法
标记法就是，将可达的对象标记起来，不可达的对象当成垃圾回收。
从初始的`根对象（window或者global）`的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象`可达`，并为其进行标记，然后接着`递归搜索`，直到所有子节点被遍历结束。那么没有被遍历到的节点，也就没有被标记，会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。
    
    // 可达
    const name = 'jelon'
    const obj = {
        name: 'leo'
    }
    console.log(window.name)
    console.log(window.obj.name)
    
    // 不可达
    function fun() {
        const name = 'chen'
    }
    console.log(window.age) // undefined

　　普通的理解其实是不够的，因为垃圾回收机制(GC)其实不止这两个算法，
  
> JavaScript内存管理
> * 分配给使用者所需的内存
> * 使用者拿到这些内存，并使用内存
> * 使用者不需要这些内存了，释放并归还给系统

    const num = 1;
    const str = 'zl';
    const obj = { name: 'zl' };
    obj = { name: 'zl' };
上面这些`num`，`str`，`obj`就是就是使用者。JavaScript数据类型分为基础数据类型和引用数据类型:
* 基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问
* 引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问
* 由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是`操作系统`自动分配和释放回收的
* 由于堆内存所存大小不固定，系统无法自动释放回收，所以需要`JS引擎`来`手动`释放这些内存

# V8垃圾回收算法
## 分代回收
在JavaScript中，对象存活周期分为两种情况；
* 存活周期很短：经过一次垃圾回收后，就被释放回收掉
* 存活周期很长：经过多次垃圾回收后，他还存在，赖着不走

对于存活周期短的,回收掉就算了,对于存活周期长的,多次回收都回收不掉,明知回收不掉,却还不断地去做回收无用功,很消耗性能

对于这个问题，V8做了`分代回收`的优化方法，通俗点说就是：V8将堆分为两个空间，一个叫`新生代`，一个叫`老生代`，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方。

新生代通常只有1-8M的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了不同的垃圾回收器和不同的回收算法，以便更高效地实施垃圾回收。

* 副垃圾回收器 + `Scavenge`算法：主要负责新生代的垃圾回收
* 主垃圾回收器 + `Mark-Sweep` && `Mark-Compact`算法：主要负责老生代的垃圾回收

### 新生代

Scavenge算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。
Scavange算法将新生代堆分为两部分，分别叫`from-space`和`to-space`，工作方式也很简单，就是将from-space中存活的活动对象复制到to-space中，并将这些对象的内存有序的排列起来，然后将from-space中的非活动对象的内存进行释放，完成之后，将from space 和to space进行互换，这样可以使得新生代中的这两块区域可以重复利用。
1. 标记活动对象和非活动对象
2. 复制from-space的活动对象到to-space中并进行排序
3. 清除from-space中的非活动对象
4. 将from-space和to-space进行角色互换，以便下一次的Scavenge算法垃圾回收
垃圾回收器如何判断活动对象和非活动对象：可达性

新生代中的对象什么时候变成老生代的对象？

在新生代中，还进一步进行了细分。分为`nursery子代`和`intermediate子代`两个区域，一个对象第一次分配内存时会被分配到新生代中的`nursery子代`，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到`intermediate子代`，在经过下一次垃圾回收，如果这个对象还在新生代中，`副垃圾回收器`会将该对象移动到老生代中，这个移动的过程被称为`晋升`

### 老生代
老生代里，回收算法不宜使用Scavenge算法
* `Scavenge算法`是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低
* `Scavenge算法`是以空间换时间的算法，老生代是内存很大的空间，如果使用Scavenge算法，空间资源非常浪费，得不偿失
所以老生代里使用了`Mark-Sweep算法(标记清理)`和`Mark-Compact算法(标记整理)`

#### Mark-Sweep(标记清理)
`Mark-Sweep`分为两个阶段，标记和清理阶段，之前的`Scavenge算法`也有标记和清理，但是`Mark-Sweep算法`跟`Scavenge算法`的区别是，后者需要复制后再清理，前者不需要，`Mark-Sweep`直接标记活动对象和非活动对象之后，就直接执行清理了。
* 标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记
* 清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象

**由上流程可发现一个问题：清除非活动对象之后，留下了很多`零零散散的空位`。**
#### Mark-Compact(标记整理)
`Mark-Sweep算法`执行垃圾回收之后，留下了很多`零零散散的空位`，这有什么坏处呢？如果此时进来了一个大对象，需要对此对象分配一个大内存，先从零零散散的空位中找位置，找了一圈，发现没有适合自己大小的空位，只好拼在了最后，这个寻找空位的过程是`耗性能`的，这也是`Mark-Sweep算法`的一个`缺点`

这个时候`Mark-Compact算法`出现了，他是`Mark-Sweep算法`的加强版，在`Mark-Sweep算法`的基础上，加上了`整理阶段`，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存

### 全停顿(Stop-The-World)
说完V8的分代回收，咱们来聊聊一个问题。

JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，`垃圾回收优先于代码执行`，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为`全停顿`
* 由于新生代空间小，并且存活对象少，再配合`Scavenge算法`，停顿时间较短。
* 但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了`卡顿现象`。

### Orinoco优化
orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决`全停顿`问题，它提出了`增量标记`、`懒性清理`、`并发`、`并行`的优化方法。

#### 增量标记(Incremental marking)
咱们前面不断强调了`先标记`，`后清除`，而增量`标记`就是在标记这个阶段进行了优化。

当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：`标记一点，JS代码运行一段`，从而提高效率
#### 惰性清理(Lazy sweeping)
增量标记之后，清理非活动对象时，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，就延迟了清理，让JS代码先执行，或者只清理部分垃圾，不清理全部。这个优化就叫做惰性清理
>标记在js代码执行前后状态不一致，需要使用`写屏障`技术来记录这些引用关系的变化
#### 并发(Concurrent)
并发式GC允许在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。

由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行`写屏障`操作。
#### 并行
并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）
>可以理解为高配置高硬件换时间？

## V8当前的垃圾回收机制
2011年，V8应用了`增量标记机制`。直至2018年，Chrome64和Node.js V10启动并发`标记`（Concurrent），同时在并发的基础上添加`并行`（Parallel）技术，使得垃圾回收时间大幅度缩短。
### 副垃圾回收器
V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从from-to复制到space-to的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。
### 主垃圾回收器
V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，`写入屏障（write barriers）`技术会在辅助线程在进行并发标记的时候进行追踪。

当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。
