# 垃圾回收机制有两种方式：引用法 和 标记法
[原文地址](https://juejin.cn/post/6995706341041897486)
## 引用法
就是判断一个对象的引用数，引用数为0就回收，引用数大于0就不回收

    let obj1 = { name: 'jelon', age: 22 }
    let obj2 = obj1
    let obj3 = obj1
    
    obj1 = null
    obj2 = null
    obj3 = null
随着obj1,obj2,obj3依次置空，堆内存中的内存块引用数为3，2，1，0，然后被释放。
但是此种方式也是有缺点的，如果存在互相引用，各自引用数都是1，则不会被回收，从而造成内存泄漏。

## 标记法
标记法就是，将可达的对象标记起来，不可达的对象当成垃圾回收。
从初始的`根对象（window或者global）`的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象`可达`，并为其进行标记，然后接着`递归搜索`，直到所有子节点被遍历结束。那么没有被遍历到的节点，也就没有被标记，会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。
    
    // 可达
    const name = 'jelon'
    const obj = {
        name: 'leo'
    }
    console.log(window.name)
    console.log(window.obj.name)
    
    // 不可达
    function fun() {
        const name = 'chen'
    }
    console.log(window.age) // undefined

　　普通的理解其实是不够的，因为垃圾回收机制(GC)其实不止这两个算法，
  
> JavaScript内存管理
> * 分配给使用者所需的内存
> * 使用者拿到这些内存，并使用内存
> * 使用者不需要这些内存了，释放并归还给系统

    const num = 1;
    const str = 'zl';
    const obj = { name: 'zl' };
    obj = { name: 'zl' };
上面这些`num`，`str`，`obj`就是就是使用者。JavaScript数据类型分为基础数据类型和引用数据类型:
* 基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问
* 引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问
* 由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是`操作系统`自动分配和释放回收的
* 由于堆内存所存大小不固定，系统无法自动释放回收，所以需要`JS引擎`来`手动`释放这些内存

# V8垃圾回收算法
## 分代回收
在JavaScript中，对象存活周期分为两种情况；
* 存活周期很短：经过一次垃圾回收后，就被释放回收掉
* 存活周期很长：经过多次垃圾回收后，他还存在，赖着不走

对于存活周期短的,回收掉就算了,对于存活周期长的,多次回收都回收不掉,明知回收不掉,却还不断地去做回收无用功,很消耗性能

对于这个问题，V8做了`分代回收`的优化方法，通俗点说就是：V8将堆分为两个空间，一个叫`新生代`，一个叫`老生代`，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方。

新生代通常只有1-8M的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了不同的垃圾回收器和不同的回收算法，以便更高效地实施垃圾回收。

* 副垃圾回收器 + `Scavenge`算法：主要负责新生代的垃圾回收
* 主垃圾回收器 + `Mark-Sweep` && `Mark-Compact`算法：主要负责老生代的垃圾回收

### 新生代

Scavenge算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。
Scavange算法将新生代堆分为两部分，分别叫`from-space`和`to-space`，工作方式也很简单，就是将from-space中存活的活动对象复制到to-space中，并将这些对象的内存有序的排列起来，然后将from-space中的非活动对象的内存进行释放，完成之后，将from space 和to space进行互换，这样可以使得新生代中的这两块区域可以重复利用。
1. 标记活动对象和非活动对象
2. 复制from-space的活动对象到to-space中并进行排序
3. 清除from-space中的非活动对象
4. 将from-space和to-space进行角色互换，以便下一次的Scavenge算法垃圾回收

