# 垃圾回收机制有两种方式：引用法 和 标记法
## 引用法
就是判断一个对象的引用数，引用数为0就回收，引用数大于0就不回收

    let obj1 = { name: 'jelon', age: 22 }
    let obj2 = obj1
    let obj3 = obj1
    
    obj1 = null
    obj2 = null
    obj3 = null
随着obj1,obj2,obj3依次置空，堆内存中的内存块引用数为3，2，1，0，然后被释放。
但是此种方式也是有缺点的，如果存在互相引用，各自引用数都是1，则不会被回收，从而造成内存泄漏。

## 标记法
标记法就是，将可达的对象标记起来，不可达的对象当成垃圾回收。
从初始的`根对象（window或者global）`的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象`可达`，并为其进行标记，然后接着`递归搜索`，直到所有子节点被遍历结束。那么没有被遍历到的节点，也就没有被标记，会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。
    
    // 可达
    const name = 'jelon'
    const obj = {
        name: 'leo'
    }
    console.log(window.name)
    console.log(window.obj.name)
    
    // 不可达
    function fun() {
        const name = 'chen'
    }
    console.log(window.age) // undefined

　　普通的理解其实是不够的，因为垃圾回收机制(GC)其实不止这两个算法，
  
> JavaScript内存管理
> * 分配给使用者所需的内存
> * 使用者拿到这些内存，并使用内存
> * 使用者不需要这些内存了，释放并归还给系统
